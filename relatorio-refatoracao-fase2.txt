RELATÓRIO DE REFATORAÇÃO — FASE 2


1. Problemas identificados


1.1 Uso direto de params sem strong parameters em Operations

No OperationsController#create os parâmetros cryptocurrency_id, operation_type e amount eram lidos diretamente de params (params[:cryptocurrency_id], params[:operation_type], params[:amount]), sem uso de permit. Isso expunha o sistema a risco de mass assignment caso novos atributos fossem adicionados ao model ou ao hash repassado ao serviço, e deixava a lista de parâmetros aceitos implícita e inconsistente em relação ao CryptocurrenciesController.


1.2 Validações opacas e sem mensagens por campo

Os models Cryptocurrency e Operation possuíam apenas o método valid? retornando true ou false, sem expor quais atributos falharam nem as mensagens de erro. As mensagens exibidas na API eram genéricas ("name, symbol and price are required", "operation_type (buy/sell) and amount required"), o que dificultava o uso da API e a correção de formulários pelos clientes, além de concentrar a descrição do erro no controller/serviço em vez do domínio.


1.3 Tratamento de erros disperso e inconsistente

Cada controller tratava not found e erros de validação de forma própria, com blocos respond_to e render json repetidos em vários pontos. Não havia um padrão único para o formato de resposta de erro (chave "error" vs "errors", status HTTP) nem um ponto central para evoluir ou auditar o comportamento de erro da aplicação.


1.4 Mistura de camada HTTP com domínio

Os controllers repassavam params (ou hashes montados a partir de params) diretamente aos serviços, sem delimitar claramente a fronteira entre "parâmetros da requisição" e "atributos de domínio". Não havia uma lista explícita e única de parâmetros permitidos por recurso, o que dificultava revisão de segurança e manutenção.


2. Melhorias aplicadas


2.1 Strong parameters consistentes

Foi definida uma lista explícita de parâmetros permitidos por controller, por meio da constante PERMITTED_PARAMS e do método privado de params em cada controller. No CryptocurrenciesController: PERMITTED_PARAMS = %i[name symbol price image], com o método cryptocurrency_params que faz params.permit(PERMITTED_PARAMS).to_h.symbolize_keys. No OperationsController: PERMITTED_PARAMS = %i[cryptocurrency_id operation_type amount], com operation_params fazendo params.permit(PERMITTED_PARAMS).to_h.symbolize_keys. As actions create e update passam a usar apenas esses métodos; nenhum parâmetro é lido diretamente de params nas operações de escrita. Com isso, strong parameters passam a ser usados de forma consistente em todos os endpoints que recebem dados do cliente.


2.2 Validações mais claras nos models

Foi introduzido o concern Validatable (app/models/concerns/validatable.rb), que fornece o método errors (hash de atributo => lista de mensagens), o método valid? (que passa a preencher errors e retornar true apenas quando não há erros) e add_error(attribute, message). Os models Cryptocurrency e Operation passaram a incluir Validatable e a implementar o método privado validate, onde as regras são declaradas por atributo com mensagens objetivas. Cryptocurrency: name e symbol "can't be blank"; price "must be present and greater than or equal to 0". Operation: cryptocurrency_id "must be a valid cryptocurrency"; operation_type "must be buy or sell"; amount "must be greater than 0". Os serviços de criação passam a retornar, em caso de falha de validação, ServiceResult.failure(errors: model.errors, error_code: :validation_failed), expondo assim erros por campo na API (payload { errors: { name: ["can't be blank"], ... } }).


2.3 Tratamento padronizado de erros no ApplicationController

No ApplicationController foram adicionados métodos protegidos para respostas de erro: render_not_found(message) para 404 (JSON com { error: message } e HTML com plain); render_validation_errors(errors, status:) para 422 com payload { errors: errors } (suporta errors como Hash ou string) e re-renderização do formulário em HTML; render_resource_error(message, status:) para erro de recurso (ex. cryptocurrency not found) em JSON e HTML; render_service_failure(result) que, a partir do error_code do ServiceResult (not_found, cryptocurrency_not_found ou demais), chama o helper adequado. Os controllers passaram a usar esses métodos em vez de repetir blocos de render, centralizando formato e status de erro e facilitando alterações futuras.


2.4 Separação entre params e domínio

A fronteira entre camada HTTP e domínio foi explicitada: os controllers não repassam o objeto params aos serviços; apenas hashes produzidos por métodos privados (cryptocurrency_params, operation_params), já filtrados por permit e convertidos para símbolos. Os serviços recebem apenas um hash de atributos (parâmetro nomeado como attributes nas assinaturas) e não dependem de ActionController::Parameters. A lista de atributos aceitos fica definida uma única vez por recurso (PERMITTED_PARAMS + método _params), e a conversão de tipos (por exemplo price para Float) permanece nos serviços, mantendo o domínio isolado da representação HTTP.


3. Impacto na segurança


3.1 Mitigação de mass assignment

O uso obrigatório de strong parameters em todos os pontos que recebem dados do cliente (create e update de cryptocurrencies, create de operations) garante que apenas os atributos listados em PERMITTED_PARAMS possam ser aceitos. Inclusão futura de novos atributos nos models ou nos hashes de criação/atualização exige a decisão explícita de adicionar o nome ao PERMITTED_PARAMS do controller correspondente, reduzindo o risco de aceitar parâmetros não intencionados.


3.2 Superfície de entrada controlada

Cada recurso expõe uma superfície de entrada explícita (constante + método privado). Isso facilita revisões de segurança e auditoria: é possível verificar em um único lugar quais parâmetros são aceitos por rota.


3.3 Isolamento da camada HTTP

Ao não passar params diretamente para a camada de aplicação, evitamos que objetos da requisição (com métodos e comportamentos específicos do Rails) vazem para o domínio. O domínio passa a trabalhar apenas com hashes de símbolos, o que reduz surpresas e acoplamento ao framework na camada de serviço e de modelo.


4. Redução de riscos


4.1 Risco de mass assignment (médio para baixo)

Antes: OperationsController aceitava apenas três chaves por montagem manual do hash, mas qualquer alteração futura que repassasse params ou um hash não filtrado poderia introduzir mass assignment. Agora: todas as escritas passam por permit com lista explícita; o risco de mass assignment por esquecimento ou alteração indevida é reduzido.


4.2 Risco de inconsistência e vazamento de informação em erros (baixo)

Antes: mensagens genéricas e tratamento disperso poderiam levar a respostas diferentes para situações semelhantes ou a exposição acidental de detalhes em outros formatos de erro. Agora: respostas de erro seguem um padrão (error para not found/recurso, errors para validação); validações retornam estrutura por campo, permitindo que o cliente corrija apenas o necessário sem depender de uma única mensagem genérica.


4.3 Risco de parâmetros não auditáveis (médio para baixo)

Antes: a lista de parâmetros aceitos estava implícita no código (montagem manual ou uso de permit em um ponto e não em outro). Agora: PERMITTED_PARAMS e métodos _params tornam a lista auditável e única por recurso, reduzindo o risco de aceitar parâmetros não revisados.


4.4 Manutenção e evolução

A centralização do tratamento de erros no ApplicationController e a validação no domínio (Validatable + validate nos models) facilitam a evolução futura: inclusão de novos códigos de erro, alteração de mensagens ou de formato de resposta pode ser feita em poucos pontos, com impacto previsível em toda a API.
