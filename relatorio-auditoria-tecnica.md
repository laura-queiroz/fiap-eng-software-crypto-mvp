# Relatório de Auditoria Técnica — MVP Mini Sistema de Moedas Digitais

## 1. Resumo Executivo

O MVP é uma aplicação Rails 7 em modo API com suporte a HTML para formulários, sem banco de dados e com persistência em memória via `Repositories::InMemoryStore`. A auditoria identificou **problemas arquiteturais relevantes** (controllers com lógica de negócio, repositório monolítico e estado global), **violações de SOLID** (principalmente SRP, OCP e DIP), **riscos de segurança** (ausência de autenticação/autorização, uso direto de params em Operations e configurações de produção relaxadas) e **code smells** que prejudicam manutenção e evolução. O projeto está adequado como protótipo didático, mas **não está pronto para produção** nem para evolução sustentável sem refatorações. Recomenda-se introduzir camada de serviços, abstrações para persistência, validações com mensagens por campo, strong parameters em todas as actions e, se houver previsão de deploy, autenticação, proteção de host e revisão de credenciais.

---

## 2. Problemas Arquiteturais

| # | Descrição técnica | Localização aproximada | Severidade | Impacto técnico | Sugestão conceitual de melhoria |
|---|-------------------|------------------------|------------|-----------------|----------------------------------|
| 2.1 | **Falta de camada de aplicação (services)** — Toda orquestração (validação, cálculo de custo, atribuição de ID, persistência) está nos controllers. Controllers conhecem detalhes do repositório e das regras de negócio. | `app/controllers/cryptocurrencies_controller.rb`, `app/controllers/operations_controller.rb` | Alta | Dificulta testes unitários, reuso e evolução; qualquer mudança de regra exige alterar controllers. | Introduzir uma camada de Application Services (ou Use Cases) que orquestram models e repositórios; controllers apenas delegam e formatam resposta (JSON/HTML). |
| 2.2 | **Repositório monolítico e estado global** — Uma única classe armazena duas entidades (cryptocurrencies e operations), gera IDs e expõe finders. Uso de variáveis de classe e métodos de classe torna o “store” um singleton implícito. | `app/models/repositories/in_memory_store.rb` | Alta | Acoplamento forte em todo o sistema; troca de persistência (ex.: BD) exige alteração em vários pontos; estado não isolado por request/tenant; em múltiplos processos o estado não é compartilhado. | Separar repositórios por entidade (ex.: `CryptocurrencyRepository`, `OperationRepository`) e definir interfaces/contratos; permitir injeção de dependência para trocar implementação (in-memory, BD, etc.). |
| 2.3 | **Repositório em app/models** — O repositório está em `app/models/repositories/`, misturando conceito de “modelo de domínio” com “infraestrutura de persistência”. | `app/models/repositories/in_memory_store.rb` | Média | Confusão de responsabilidades e convenções Rails (models costumam ser entidades ou queries). | Mover repositórios para `app/repositories/` (ou `lib/repositories/`) e manter em `app/models` apenas entidades de domínio (Cryptocurrency, Operation). |
| 2.4 | **Ausência de abstração de persistência** — Controllers e fluxos dependem diretamente da classe concreta `Repositories::InMemoryStore`. Não há interface ou contrato que permita trocar a implementação. | Todos os controllers que usam `Repositories::InMemoryStore` | Alta | Viola DIP e OCP; qualquer nova forma de persistência obriga a alterar controllers. | Definir interfaces/contratos (por exemplo via módulos ou classes abstratas) para repositórios e injetar a implementação (in-memory, depois BD) no controller ou em um service. |
| 2.5 | **Regras de negócio no controller** — Cálculo de `operation_date` (Time.now) e `cryptocurrency_price` (busca da crypto) são feitos no controller; atribuição de `id` e persistência também. | `app/controllers/operations_controller.rb` (create), `app/controllers/cryptocurrencies_controller.rb` (create, update, destroy) | Alta | Regras espalhadas fora do domínio; difícil garantir consistência e testar. | Mover criação e persistência de entidades para services ou para os próprios models/repositórios; controller apenas chama um “create_operation” (ou similar) e trata erros. |
| 2.6 | **Inconsistência de formatos de resposta** — Algumas actions respondem JSON e HTML (index, show, new, create em cryptocurrencies); update e destroy em cryptocurrencies só retornam JSON; em operations, show só retorna JSON. | `app/controllers/cryptocurrencies_controller.rb`, `app/controllers/operations_controller.rb` | Média | API e UI inconsistentes; clientes HTML podem não ter feedback adequado em update/destroy ou em show de operations. | Padronizar: para cada action, definir claramente se há suporte HTML e JSON e aplicar o mesmo padrão (ex.: respond_to em todas ou separar API em namespace). |
| 2.7 | **Estado em memória não thread-safe** — Arrays e contadores de ID são variáveis de classe sem sincronização. Em servidor multi-thread (ex.: Puma com threads > 1), concorrência pode causar IDs duplicados ou corrupção de listas. | `app/models/repositories/in_memory_store.rb` | Média | Em produção com múltiplas threads, risco de perda de dados ou IDs incorretos. | Se manter in-memory, usar estruturas thread-safe (ex.: Mutex ao modificar listas/contadores) ou documentar que o app é single-thread; ao evoluir para BD, o problema é mitigado pelo próprio SGBD. |

---

## 3. Violações de SOLID

| # | Princípio | Descrição técnica | Localização aproximada | Severidade | Impacto técnico | Sugestão conceitual de melhoria |
|---|-----------|-------------------|------------------------|------------|-----------------|----------------------------------|
| 3.1 | **SRP** | Controllers têm múltiplas responsabilidades: receber request, validar params, aplicar regras de negócio (montar attrs, buscar crypto, definir data/preço), persistir, decidir formato (JSON/HTML) e responder. | `app/controllers/cryptocurrencies_controller.rb`, `app/controllers/operations_controller.rb` | Alta | Alta complexidade por classe; mudanças em regra de negócio ou em formato de resposta afetam a mesma classe. | Restringir controllers a: receber params, chamar service (ou use case), e renderizar/redirect conforme resultado; validação e persistência em services/repositórios. |
| 3.2 | **SRP** | `InMemoryStore` concentra: armazenamento de duas entidades distintas, geração de IDs para ambas e find por id. Uma única classe tem mais de uma razão para mudar. | `app/models/repositories/in_memory_store.rb` | Alta | Adicionar nova entidade ou nova forma de geração de ID exige alterar a mesma classe. | Uma classe de repositório por entidade; geração de ID pode ficar em cada repositório ou em um componente específico (ex.: ID generator injetado). |
| 3.3 | **OCP** | Comportamento do sistema é estendido alterando controllers e o repositório diretamente (novas regras, novos formatos, nova persistência). Não há extensão por novos comportamentos sem modificar código existente. | Controllers e `Repositories::InMemoryStore` | Média | Evolução exige tocar em código já estável; risco de regressão. | Abstrair persistência (interfaces) e orquestração (services); novos formatos de resposta podem ser objetos “presenters” ou serializers; novas regras em services. |
| 3.4 | **DIP** | Controllers e fluxos dependem de implementação concreta `Repositories::InMemoryStore` (chamadas diretas à classe). Não há dependência em abstrações. | Controllers que referenciam `Repositories::InMemoryStore` | Alta | Impossível trocar implementação (ex.: por repositório com BD) sem alterar controllers. | Controllers (ou services) receberem dependências por construtor/setter (repositórios como interfaces); container ou initializer injeta `InMemoryStore` ou futura implementação. |
| 3.5 | **SRP / responsabilidade do model** | Models expõem `valid?` sem detalhes de erro; parte da “validação” (ex.: preço obrigatório, tipo de operação) está implícita ou duplicada no controller. Cryptocurrency faz conversão de tipo no initialize (`to_f`, `to_s`) que pode mascarar entradas inválidas. | `app/models/cryptocurrency.rb`, `app/models/operation.rb` | Média | Dificulta feedback rico na API (erros por campo) e reuso; conversões podem esconder bugs. | Models (ou objetos de validação) retornarem lista de erros por atributo; conversões e validações explícitas antes de atribuir ao model. |

---

## 4. Problemas de Segurança

| # | Descrição técnica | Localização aproximada | Severidade | Impacto técnico | Sugestão conceitual de melhoria |
|---|-------------------|------------------------|------------|-----------------|----------------------------------|
| 4.1 | **Ausência de autenticação e autorização** — Todas as rotas são públicas. Qualquer pessoa pode criar, alterar e excluir criptomoedas e operações. | `config/routes.rb`, `app/controllers/*` (nenhum before_action de auth) | Alta | Em ambiente compartilhado ou público, dados podem ser alterados ou apagados por terceiros. | Introduzir autenticação (ex.: sessão, token, Devise) e autorização por recurso se houver múltiplos usuários; para MVP didático, documentar que o app não é para uso em produção sem auth. |
| 4.2 | **Uso direto de params sem strong parameters** — Em OperationsController#create, `params[:cryptocurrency_id]`, `params[:operation_type]` e `params[:amount]` são usados diretamente. O hash de atributos é montado à mão, mas novos parâmetros poderiam ser aceitos sem lista explícita, facilitando mass assignment no futuro. | `app/controllers/operations_controller.rb` (create) | Média | Risco de mass assignment se alguém adicionar atributos ao model sem filtrar params. | Usar sempre `params.permit(...)` (ou strong parameters) para qualquer atributo que vá para model/repositório; manter lista explícita de atributos permitidos. |
| 4.3 | **IDOR (Insecure Direct Object Reference)** — Não há noção de “dono” ou escopo; qualquer recurso pode ser lido, alterado ou removido por id. Com persistência em BD e múltiplos usuários, isso permitiria acesso a dados alheios. | Controllers em show, update, destroy | Média | Em cenário multi-usuário, usuário A poderia acessar/alterar recursos de B. | Quando houver usuários, filtrar recursos por escopo (ex.: user_id); verificar permissão antes de show/update/destroy. |
| 4.4 | **Proteção de host desabilitada** — Em produção, `config.hosts` e `config.host_authorization` estão comentados, desativando proteção contra DNS rebinding e ataques via cabeçalho Host. | `config/environments/production.rb` | Média | Se o app for exposto à internet, ataques de DNS rebinding ou redirecionamento indevido são possíveis. | Habilitar e configurar `config.hosts` (e host_authorization se aplicável) com os domínios permitidos antes de colocar em produção. |
| 4.5 | **Credenciais e master key** — Uso de `credentials.yml.enc` e `config/master.key`. Se o repositório for público ou compartilhado e o `master.key` tiver sido commitado em algum momento, credenciais descriptografadas ficam acessíveis. O `.gitignore` já ignora `config/master.key`; o risco é histórico ou repositórios que não o utilizem. | `config/credentials.yml.enc`, `config/master.key`, `.gitignore` | Alta (se key versionada) | Vazamento de segredos (chaves de API, senhas, etc.). | Garantir que `master.key` nunca seja versionado; em times, usar variáveis de ambiente ou gestão de segredos (ex.: RAILS_MASTER_KEY em CI/CD); considerar `config.require_master_key = true` em produção. |
| 4.6 | **Dados sensíveis em logs** — Filter_parameter_logging está configurado para não logar passw, secret, token, etc. Não há evidência de log de params completos em produção; manter a boa prática. | `config/initializers/filter_parameter_logging.rb` | Baixa | Boa prática já adotada; revisar se novos parâmetros sensíveis forem adicionados. | Incluir na lista qualquer novo parâmetro sensível (ex.: api_key, password, token). |

---

## 5. Code Smells Identificados

| # | Descrição técnica | Localização aproximada | Severidade | Impacto técnico | Sugestão conceitual de melhoria |
|---|-------------------|------------------------|------------|-----------------|----------------------------------|
| 5.1 | **Controllers gordos (lógica de negócio e persistência)** — Create/update contêm validação, montagem de atributos, atribuição de id, persistência e decisão de resposta. | `app/controllers/cryptocurrencies_controller.rb`, `app/controllers/operations_controller.rb` | Alta | Difícil leitura, teste e manutenção. | Extrair para services: “CreateCryptocurrency”, “CreateOperation”, “UpdateCryptocurrency”, etc.; controllers ficam finos. |
| 5.2 | **Duplicação de tratamento “not found”** — Padrão “buscar por id → se não encontrado, render json/plain com 404” repetido em vários actions e controllers. | `CryptocurrenciesController#show`, `#update`, `#destroy`; `OperationsController#show`, `#create` | Média | Duplicação e inconsistência de mensagens/status. | Centralizar em um concern, before_action ou método auxiliar (ex.: `find_cryptocurrency!` que levanta exceção ou define @resource e retorna 404 se nil). |
| 5.3 | **Duplicação de respond_to (JSON/HTML)** — Blocos respond_to repetidos em várias actions com estrutura similar. | Controllers em index, show, create e tratamento de erro | Média | Código verboso e repetitivo. | Extrair formatos de resposta para métodos ou presenters; ou padronizar em um único formato por action e usar convenções. |
| 5.4 | **Mensagens de erro genéricas** — Em create, retorna-se uma única mensagem (“name, symbol and price are required” ou “operation_type (buy/sell) and amount required”) em vez de erros por campo. | `CryptocurrenciesController#create`, `OperationsController#create` | Média | Experiência ruim para cliente da API e para formulários (não sabe qual campo corrigir). | Models (ou validators) retornarem hash de erros por atributo; controller/serializer expor esse hash em `errors` no JSON e na view. |
| 5.5 | **Validação sem mensagens** — `valid?` nos models retorna apenas true/false; não há `errors` ou lista de mensagens por atributo. | `app/models/cryptocurrency.rb`, `app/models/operation.rb` | Média | Impossível expor erros granulares na API ou na UI. | Introduzir objeto de erros (ex.: array ou hash) preenchido durante validação; método `errors` ou `full_messages` no model ou em um validator dedicado. |
| 5.6 | **Acoplamento a “agora” (Time.now)** — Operation usa `Time.now` no initialize quando `operation_date` não é informado. Dificulta testes e regras por timezone. | `app/models/operation.rb` (initialize); montagem de attrs em `OperationsController#create` | Baixa | Testes dependem do relógio do sistema; mudança para timezone ou “data da operação” exige alteração em mais de um lugar. | Permitir injetar um “clock” ou “operation_date” sempre; em testes, injetar data fixa; em produção, usar Time.current (Rails) e configurar timezone. |
| 5.7 | **Conversão silenciosa de tipos** — Cryptocurrency e Operation usam `to_f` e `to_s` no initialize; string vazia ou inválida pode virar 0.0 ou string vazia sem falha explícita. | `app/models/cryptocurrency.rb`, `app/models/operation.rb` | Média | Dados inválidos podem ser aceitos (ex.: price = 0); validação pode falhar depois de forma genérica. | Validar formato/tipo antes de atribuir ou usar conversões que falhem (ex.: Float(value) com tratamento de exceção); expor erro por campo. |
| 5.8 | **Update/destroy só em JSON** — CryptocurrenciesController#update e #destroy não respondem em HTML; usuário que usa apenas a interface web não tem feedback padronizado. | `app/controllers/cryptocurrencies_controller.rb` (update, destroy) | Baixa | Inconsistência de interface; se houver links “editar”/“excluir” em HTML, pode ser necessário JavaScript ou redirecionamento manual. | Decidir se update/destroy terão versão HTML (ex.: redirect com flash); se sim, usar respond_to para ambos os formatos. |
| 5.9 | **Repositório como “singleton” global** — Acesso direto à classe `Repositories::InMemoryStore` em todo o código; estado compartilhado e não injetável. | Uso em todos os controllers e em qualquer lugar que chame o store | Média | Testes precisam limpar estado global; impossível isolar cenários (ex.: um teste com store vazio, outro com dados). | Injetar instância do repositório (ou interface) nos controllers/services; em testes, injetar implementação fake ou limpar explicitamente no setup. |
| 5.10 | **Sem namespace ou versionamento de API** — Rotas não estão sob `api/v1` (ou similar); evolução futura da API pode quebrar clientes. | `config/routes.rb` | Baixa | Ao mudar contrato (ex.: campos, status), não há forma de manter compatibilidade com versão antiga. | Se a API for consumida por clientes externos, considerar `namespace :api do namespace :v1 do ... end end` e versionar recursos. |

---

*Relatório gerado com foco em sustentabilidade, segurança e qualidade arquitetural. Sugestões são conceituais; a implementação deve ser adaptada ao contexto didático e ao roadmap do projeto.*
